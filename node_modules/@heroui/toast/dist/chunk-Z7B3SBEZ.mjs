"use client";
import {
  toast_default
} from "./chunk-YZOK25NS.mjs";

// src/toast-region.tsx
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useToastRegion } from "@react-aria/toast";
import { useHover } from "@react-aria/interactions";
import { toastRegion } from "@heroui/theme";
import { clsx, mergeProps } from "@heroui/shared-utils";
import { AnimatePresence } from "framer-motion";

// src/toast-provider.tsx
import { ToastQueue, useToastQueue } from "@react-stately/toast";
import { useProviderContext } from "@heroui/system";
import { LazyMotion } from "framer-motion";
import { jsx } from "react/jsx-runtime";
var loadFeatures = () => import("framer-motion").then((res) => res.domMax);
var globalToastQueue = null;
var getToastQueue = () => {
  if (!globalToastQueue) {
    globalToastQueue = new ToastQueue({
      maxVisibleToasts: Infinity
    });
  }
  return globalToastQueue;
};
var ToastProvider = ({
  placement = "bottom-right",
  disableAnimation: disableAnimationProp = false,
  maxVisibleToasts = 3,
  toastOffset = 0,
  toastProps = {},
  regionProps
}) => {
  var _a;
  const toastQueue = useToastQueue(getToastQueue());
  const globalContext = useProviderContext();
  const disableAnimation = (_a = disableAnimationProp != null ? disableAnimationProp : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _a : false;
  return /* @__PURE__ */ jsx(LazyMotion, { features: loadFeatures, children: toastQueue.visibleToasts.length > 0 && /* @__PURE__ */ jsx(
    ToastRegion,
    {
      disableAnimation,
      maxVisibleToasts,
      placement,
      toastOffset,
      toastProps,
      toastQueue,
      ...regionProps
    }
  ) });
};
var addToast = ({ ...props }) => {
  if (!globalToastQueue) {
    return null;
  }
  return globalToastQueue.add(props);
};
var closingToasts = /* @__PURE__ */ new Map();
var closeToast = (key) => {
  if (!globalToastQueue) {
    return;
  }
  if (closingToasts.has(key)) {
    return;
  }
  const timeoutId = setTimeout(() => {
    closingToasts.delete(key);
    globalToastQueue == null ? void 0 : globalToastQueue.close(key);
  }, 300);
  closingToasts.set(key, timeoutId);
};
var closeAll = () => {
  if (!globalToastQueue) {
    return;
  }
  const toasts = [...globalToastQueue.visibleToasts];
  toasts.forEach((toast) => {
    closeToast(toast.key);
  });
};
var isToastClosing = (key) => closingToasts.has(key);

// src/toast-region.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
function ToastRegion({
  toastQueue,
  placement,
  disableAnimation,
  maxVisibleToasts,
  toastOffset,
  toastProps = {},
  className,
  classNames,
  ...props
}) {
  var _a, _b;
  const ref = useRef(null);
  const { regionProps } = useToastRegion(props, toastQueue, ref);
  const { hoverProps, isHovered } = useHover({
    isDisabled: false
  });
  const [isTouched, setIsTouched] = useState(false);
  const slots = useMemo(
    () => toastRegion({
      disableAnimation
    }),
    [disableAnimation]
  );
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  useEffect(() => {
    function handleTouchOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        setIsTouched(false);
      }
    }
    document.addEventListener("touchstart", handleTouchOutside);
    return () => {
      document.removeEventListener("touchstart", handleTouchOutside);
    };
  }, []);
  const [heights, setHeights] = useState([]);
  const total = (_b = (_a = toastQueue.visibleToasts) == null ? void 0 : _a.length) != null ? _b : 0;
  const handleTouchStart = useCallback(() => {
    setIsTouched(true);
  }, []);
  return /* @__PURE__ */ jsx2(
    "div",
    {
      ...mergeProps(regionProps, hoverProps),
      ref,
      className: slots.base({ class: baseStyles }),
      "data-placement": placement,
      onTouchStart: handleTouchStart,
      children: /* @__PURE__ */ jsx2(AnimatePresence, { children: [...toastQueue.visibleToasts].reverse().map((toast, index) => {
        if (disableAnimation && total - index > maxVisibleToasts) {
          return null;
        }
        if (disableAnimation || total - index <= 4 || isHovered && total - index <= maxVisibleToasts + 1) {
          const isClosing = isToastClosing(toast.key);
          return /* @__PURE__ */ jsx2(
            toast_default,
            {
              state: toastQueue,
              toast,
              ...mergeProps(toastProps, toast.content, { isClosing }),
              disableAnimation,
              heights,
              index,
              isRegionExpanded: isHovered || isTouched,
              maxVisibleToasts,
              placement,
              setHeights,
              toastOffset,
              total
            },
            toast.key
          );
        }
        return null;
      }) })
    }
  );
}

export {
  ToastRegion,
  getToastQueue,
  ToastProvider,
  addToast,
  closeToast,
  closeAll,
  isToastClosing
};
